<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>p5.js example</title>
    <style>
      body {
        padding: 0;
        margin: 0;
        background-color: #1b1b1b;
      }
    </style>
    <script src="./p5.js"></script>
    <script>
        let house, field;
        const camDistance = 600, camRotateSpeed = 0.5;
        let camX = 0, camY = -300, camZ = 200;
        let angle = 0;

        function setup() {
            createCanvas(800, 800, WEBGL);
            angleMode(DEGREES)
            frameRate(50)

            cam = createCamera()
            cam.setPosition(camX, camY, camZ)
            cam.lookAt(0, 0, 0)

            // normalMaterial()

            house = buildGeometry(() => {
                push()
                fill('yellow')
                box(100)
                translate(0, -100, 0)
                rotateY(45)
                fill('red')
                cone(100, -100, 5)
                pop()
            })
            field = buildGeometry(() => {
                push()
                translate(0, 51, 0)
                // box(400,1,400)
                rotateX(90)
                fill('green')
                // plane(400, 400)
                plane(200, 200)
                pop()
            })
            // setInterval(() => {
            //     console.log(round(frameRate()))
            // }, 1000)

            background(200);
            [field].forEach(obj => {
                obj.faces.slice(1).reduce((arr, el) => {
                    if (arr.some(x => x.every(v => el.includes(v)) && x.length === el.length)) {
                        return arr
                    }
                    return [...arr, el]
                }, []).forEach((face, i) => {
                    faces.push(calculatePointsOnFace(obj, i))
                })
            })
            // console.log(faces[0].points)
            // strokeWeight(lineWidth)
            // drawLine(faces[0].points.slice(-3))
        }

        let faces = []
        let points = []
        let colors = []
        let step = 0;
        let faceIndex = 0;
        let currentFaces = [];
        const facesInSameTime = 3;
        // both speed index have to be integer, higer frame skip slows down, higher steps increment accelerates
        const speedIndexFrameSkip = 1;
        const speedIndexStepsIncrement = 1;
        const lineWidth = 5;
        const linesGap = 5;
        const distanceBetweenPoints = lineWidth + linesGap;

        const DRAW_POINTS_INSTEAD_OF_ANIMATION = true;

        function draw() {
            orbitControl()
            background(200);
            noFill();
            strokeWeight(lineWidth)

            if (DRAW_POINTS_INSTEAD_OF_ANIMATION) {
                strokeWeight(1)
                for (let f = 0; f < faces.length; f++) {
                    beginShape();
                    for (let i = 0; i < faces[f].points.length; i++) {
                        const v = faces[f].points[i]
                        // curveVertex(v.x, v.y, v.z)
                        drawPoint(v, v.color)
                    }
                    endShape();
                }
                return;
            }

            /*
            TODO
            zwielokrotnić żeby było kilka ścian jednoczesnie
             */
            for (let f = 0; f <= faceIndex; f++) {
                stroke(faces[f].color)
                beginShape();
                const lastStep = f === faceIndex ? step : faces[f].points.length
                for (let i = 0; i < lastStep; i++) {
                    const v = faces[f].points[i]
                    curveVertex(v.x, v.y, v.z)
                    // drawPoint(faces[f].points[i], faces[f].color)
                }
                endShape();
            }
            if (frameCount % speedIndexFrameSkip === 0) {
                step += speedIndexStepsIncrement
                if (step >= faces[faceIndex].points.length) {
                    faceIndex++
                    step = 0
                }
                if (faceIndex >= faces.length) {
                    faceIndex = 0
                }
            }

            // cam.setPosition(camDistance * cos(frameCount * camRotateSpeed), camY, camDistance * sin(frameCount * camRotateSpeed));
            // cam.lookAt(0, 0, 0);
            // model(house)
            // model(field)
        }

        function calculatePointsOnFace(obj, index) {
            const face = obj.faces.at(index)
            const vertices = new Array(face.length)
            let r = 0, g = 0, b = 0, a = 0
            for (let i = 0; i < face.length; i++) {
                const vertexIndex = face[i]
                vertices[i] = obj.vertices[vertexIndex]
                r += obj.vertexColors[vertexIndex * 4]
                g += obj.vertexColors[vertexIndex * 4 + 1]
                b += obj.vertexColors[vertexIndex * 4 + 2]
                a += obj.vertexColors[vertexIndex * 4 + 3]
            }
            return {
                points: getPlanePoints(vertices),
                color: [r / face.length * 255, g / face.length * 255, b / face.length * 255, a / face.length * 255]
            }
        }

        function getPlanePoints(vertices) {
            const points = [];
            const [v0, v1, v2] = vertices;

            const edgesLengths = [
                dist(v0.x, v0.y, v0.z, v1.x, v1.y, v1.z),
                dist(v1.x, v1.y, v1.z, v2.x, v2.y, v2.z),
                dist(v2.x, v2.y, v2.z, v0.x, v0.y, v0.z)
            ]

            const maxEdgeLength = Math.max(...edgesLengths);
            const maxEdgeIndex = edgesLengths.indexOf(maxEdgeLength);
            const newVertices = maxEdgeIndex === 0 ? [v0, v1, v2] : maxEdgeIndex === 1 ? [v1, v2, v0] : [v2, v0, v1]
            const density = Math.ceil(maxEdgeLength / distanceBetweenPoints);

            let lastWasEdge = false;

            const calculate = (i, j) => {
                // points.push({
                //     ...calculatePoint(...newVertices, density, i, j),
                //     color: j === 0 || j === density - i ? 'red' : 'green'
                // })
                // return
                if (i > 0 && points.length > 1 && (j === 0 || j === density - i) && lastWasEdge) {
                    const last = points.pop()
                    const newOne = calculatePoint(...newVertices, density, i, j)
                    points.push({
                        x: (last.x + newOne.x) / 2,
                        y: (last.y + newOne.y) / 2,
                        z: (last.z + newOne.z) / 2,
                        color: 'red'
                    })
                } else
                    points.push({...calculatePoint(...newVertices, density, i, j), color: 'green'})

                lastWasEdge = j === 0 || j === density - i
            }

            for (let i = 0; i <= density; i++) {
                if (i % 2 === 0)
                    for (let j = 0; j <= density - i; j++)
                        calculate(i, j)
                else
                    for (let j = density - i; j >= 0; j--)
                        calculate(i, j)
            }

            // const redIndexes = points.reduce((acc, p, i) => {
            //     if (p.color === 'red') acc.push(i)
            //     return acc
            // }, []).slice(1, -1)
            //
            // let lastIndex = 0
            // const newPoints = []
            //
            // for (let i = 0; i < redIndexes.length; i++) {
            //     if (redIndexes[i] === redIndexes[i + 1] - 1) {
            //         newPoints.push(...points.slice(lastIndex, redIndexes[i] + 1))
            //         const before = points[redIndexes[i] - 1]
            //         const after = points[redIndexes[i + 1] + 1]
            //         if (!before || !after) break
            //         newPoints.push({
            //             x: avg(before.x, after.x, points[redIndexes[i]].x, points[redIndexes[i] + 1].x),
            //             y: avg(before.y, after.y, points[redIndexes[i]].y, points[redIndexes[i] + 1].y),
            //             z: avg(before.z, after.z, points[redIndexes[i]].z, points[redIndexes[i] + 1].z),
            //             color: 'red'
            //         })
            //
            //         i += 1
            //         lastIndex = i + 1
            //         break;
            //     }
            // }
            // newPoints.push(...points.slice(lastIndex))
            // return newPoints


            // for(let i = 0; i < points.length; i++) {
            //     const p = points[i]
            //     if(p.color!=='red' || i === 0 || i === points.length - 1) break
            //     const prev = points[i - 1]
            // }

            return points;
        }

        function calculatePoint(v0, v1, v2, density, i, j) {
            const u = i / density;
            const v = j / density;
            const w = 1 - u - v;

            const x = u * v0.x + v * v1.x + w * v2.x;
            const y = u * v0.y + v * v1.y + w * v2.y;
            const z = u * v0.z + v * v1.z + w * v2.z;

            return {x, y, z}
        }

        function drawLine(points) {
            const additional = points.length < 4 ? Array.from({length: 4 - points.length})
                .map(() => points.at(-1)).flatMap(p => [p.x, p.y, p.z]) : []
            curve(...points.flatMap(p => [p.x, p.y, p.z]), ...additional)
        }

        function drawPoint(v, color) {
            push()
            fill(color)
            stroke(color)
            translate(v.x, v.y, v.z)
            sphere(1)
            pop()
        }

        function avg(...arr) {
            return arr.reduce((acc, el) => acc + el, 0) / arr.length
        }
    </script>
</head>
<body>

</body>
</html>